<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Petite Ville – Page unique</title>
  <style>
    :root {
      --sky: #cfe9ff;
      --grass: #8ad66f;
      --road: #c2c2c2;
      --house: #b5795c;
      --roof: #7a3b28;
      --door: #4c2e1f;
      --ui-bg: rgba(0,0,0,.55);
      --ui-text: #fff;
    }
    html, body {
      margin: 0; height: 100%; background: var(--sky); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    #wrap { position: fixed; inset: 0; display: grid; place-items: center; }
    canvas { background: var(--grass); box-shadow: 0 10px 30px rgba(0,0,0,.25); border-radius: 16px; }
    .hud { position: fixed; left: 12px; bottom: 12px; padding: 10px 12px; background: var(--ui-bg); color: var(--ui-text); border-radius: 10px; font-size: 14px; line-height: 1.4; }
    .hud kbd { background: rgba(255,255,255,.15); border: 1px solid rgba(255,255,255,.25); padding: 1px 6px; border-radius: 6px; font: inherit; }
    .notif { position: fixed; top: 12px; left: 50%; transform: translateX(-50%); background: var(--ui-bg); color: var(--ui-text); padding: 8px 12px; border-radius: 10px; font-size: 14px; opacity: 0; transition: opacity .2s ease; pointer-events: none; }
    .notif.show { opacity: 1; }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="960" height="540" aria-label="Jeu de ville minimal"></canvas>
  </div>
  <div class="hud" id="hud">
    Déplace-toi avec <kbd>Z</kbd><kbd>Q</kbd><kbd>S</kbd><kbd>D</kbd> ou les flèches. Interagir : <kbd>E</kbd> · Quitter une maison : <kbd>E</kbd><br/>
    Astuce : approche-toi d'une porte, un message apparaîtra.
  </div>
  <div class="notif" id="notif">Entrer <kbd>E</kbd></div>

  <script>
  // ====== Configuration générale ======
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const notif = document.getElementById('notif');

  // Mise à l'échelle selon le pixel ratio pour un rendu net
  function fitCanvas() {
    const ratio = window.devicePixelRatio || 1;
    const baseW = 960, baseH = 540; // format 16:9
    // Ajuste la taille visuelle en gardant l'aspect
    const maxW = Math.min(window.innerWidth - 24, 1200);
    const maxH = Math.min(window.innerHeight - 24, 800);
    let w = baseW, h = baseH;
    const scale = Math.min(maxW / baseW, maxH / baseH);
    w = Math.round(baseW * scale);
    h = Math.round(baseH * scale);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    canvas.width = Math.floor(w * ratio);
    canvas.height = Math.floor(h * ratio);
    ctx.setTransform(ratio * scale, 0, 0, ratio * scale, 0, 0); // garde une logique en unités "base"
  }
  window.addEventListener('resize', fitCanvas); fitCanvas();

  // ====== Monde & Scènes ======
  const Scenes = {
    Town: 'town',
    House1: 'house1',
    House2: 'house2',
  };

  let state = {
    scene: Scenes.Town,
    camera: { x: 0, y: 0 },
    player: { x: 200, y: 260, w: 20, h: 28, speed: 2.2 },
    keys: {},
  };

  // Monde extérieur (ville)
  const town = {
    w: 1600, h: 1200,
    roads: [ // routes rectangulaires simples
      { x: 0, y: 240, w: 1600, h: 60 },
      { x: 600, y: 0, w: 60, h: 1200 },
    ],
    houses: [
      { id: Scenes.House1, x: 380, y: 180, w: 120, h: 90, door: { x: 430, y: 260, w: 20, h: 20 } },
      { id: Scenes.House2, x: 900, y: 340, w: 140, h: 100, door: { x: 960, y: 420, w: 24, h: 22 } },
    ],
    colliders: [] // calculés plus bas
  };
  // Génère des colliders pour empêcher d'entrer par les murs (on laisse la porte libre)
  town.houses.forEach(h => {
    const border = 10;
    // Murs périmétriques (4 bandes), en laissant l'ouverture de la porte
    town.colliders.push({ x: h.x, y: h.y, w: h.w, h: border }); // top
    town.colliders.push({ x: h.x, y: h.y + h.h - border, w: h.w, h: border }); // bottom
    // côtés, mais on découpe autour de la porte sur le côté bas
    const door = h.door;
    // côté gauche
    town.colliders.push({ x: h.x, y: h.y, w: border, h: h.h });
    // côté droit
    town.colliders.push({ x: h.x + h.w - border, y: h.y, w: border, h: h.h });
    // bande murale basse excepté la porte
    if (door) {
      const leftSeg = { x: h.x + border, y: h.y + h.h - border, w: Math.max(door.x - (h.x + border), 0), h: border };
      const rightSeg = { x: door.x + door.w, y: h.y + h.h - border, w: Math.max((h.x + h.w - border) - (door.x + door.w), 0), h: border };
      if (leftSeg.w > 0) town.colliders.push(leftSeg);
      if (rightSeg.w > 0) town.colliders.push(rightSeg);
    }
  });

  // Intérieurs simples
  const rooms = {
    [Scenes.House1]: {
      w: 640, h: 400,
      furniture: [ // obstacles
        { x: 60, y: 80, w: 120, h: 20 }, // table
        { x: 280, y: 60, w: 60, h: 100 }, // armoire
      ],
      exit: { x: 300, y: 360, w: 40, h: 24 },
      spawn: { x: 310, y: 320 }, // où arrive le joueur depuis la porte
    },
    [Scenes.House2]: {
      w: 720, h: 460,
      furniture: [
        { x: 120, y: 120, w: 80, h: 80 }, // canapé
        { x: 420, y: 90, w: 40, h: 160 }, // bibliothèque
      ],
      exit: { x: 350, y: 420, w: 50, h: 26 },
      spawn: { x: 360, y: 380 },
    }
  };

  // ====== Utilitaires ======
  function rectsOverlap(a, b) {
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }
  function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

  // ====== Contrôles ======
  const keyMap = { ArrowUp: 'up', ArrowDown: 'down', ArrowLeft: 'left', ArrowRight: 'right', z: 'up', s: 'down', q: 'left', d: 'right', Z: 'up', S: 'down', Q: 'left', D: 'right', e: 'use', E: 'use' };
  window.addEventListener('keydown', (e) => { if (keyMap[e.key]) { state.keys[keyMap[e.key]] = true; if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)) e.preventDefault(); }});
  window.addEventListener('keyup',   (e) => { if (keyMap[e.key]) state.keys[keyMap[e.key]] = false; });

  // ====== Boucle de jeu ======
  let last = performance.now();
  function loop(t) {
    const dt = Math.min((t - last) / 16.67, 3); // frame step ~60 FPS, clamp
    last = t;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ====== Mise à jour ======
  function update(dt) {
    const p = state.player;
    const speed = p.speed * dt;
    let vx = 0, vy = 0;
    if (state.keys.left)  vx -= speed;
    if (state.keys.right) vx += speed;
    if (state.keys.up)    vy -= speed;
    if (state.keys.down)  vy += speed;
    const len = Math.hypot(vx, vy) || 1; vx /= len; vy /= len; // diagonales normalisées
    vx *= speed; vy *= speed;

    // Mouvement + collisions selon la scène
    if (state.scene === Scenes.Town) moveWithCollisionsTown(p, vx, vy);
    else moveWithCollisionsRoom(p, vx, vy);

    // Caméra centrée sur le joueur
    const viewW = 960, viewH = 540; // coordonnées "base"
    const bounds = (state.scene === Scenes.Town) ? { w: town.w, h: town.h } : rooms[state.scene];
    state.camera.x = clamp(p.x - viewW/2, 0, Math.max(bounds.w - viewW, 0));
    state.camera.y = clamp(p.y - viewH/2, 0, Math.max(bounds.h - viewH, 0));

    // Interactions
    handleInteractions();
  }

  function moveWithCollisionsTown(p, vx, vy) {
    // routes = zones de friction plus rapide (bonus discret), herbe normale
    p.x += vx; // tentative axe X
    // collisions maisons
    for (const c of town.colliders) if (rectsOverlap({x:p.x,y:p.y,w:p.w,h:p.h}, c)) {
      if (vx > 0) p.x = c.x - p.w; else if (vx < 0) p.x = c.x + c.w;
    }
    p.y += vy; // tentative axe Y
    for (const c of town.colliders) if (rectsOverlap({x:p.x,y:p.y,w:p.w,h:p.h}, c)) {
      if (vy > 0) p.y = c.y - p.h; else if (vy < 0) p.y = c.y + c.h;
    }
    // limites du monde
    p.x = clamp(p.x, 0, town.w - p.w);
    p.y = clamp(p.y, 0, town.h - p.h);
  }

  function moveWithCollisionsRoom(p, vx, vy) {
    const room = rooms[state.scene];
    p.x += vx;
    for (const f of room.furniture) if (rectsOverlap({x:p.x,y:p.y,w:p.w,h:p.h}, f)) {
      if (vx > 0) p.x = f.x - p.w; else if (vx < 0) p.x = f.x + f.w;
    }
    p.y += vy;
    for (const f of room.furniture) if (rectsOverlap({x:p.x,y:p.y,w:p.w,h:p.h}, f)) {
      if (vy > 0) p.y = f.y - p.h; else if (vy < 0) p.y = f.y + f.h;
    }
    p.x = clamp(p.x, 0, room.w - p.w);
    p.y = clamp(p.y, 0, room.h - p.h);
  }

  function handleInteractions() {
    const pbox = { x: state.player.x, y: state.player.y, w: state.player.w, h: state.player.h };
    let canEnter = false;

    if (state.scene === Scenes.Town) {
      for (const h of town.houses) {
        if (rectsOverlap(pbox, h.door)) { canEnter = true; if (state.keys.use) enterHouse(h.id); }
      }
    } else {
      const room = rooms[state.scene];
      if (rectsOverlap(pbox, room.exit)) {
        canEnter = true; if (state.keys.use) exitToTown(state.scene);
      }
    }

    notif.classList.toggle('show', canEnter);
  }

  function enterHouse(id) {
    const room = rooms[id]; if (!room) return;
    state.scene = id;
    state.player.x = room.spawn.x; state.player.y = room.spawn.y;
    // petite animation de fondu (optionnellement)
    flash();
  }
  function exitToTown(fromId) {
    // Replacer près de la porte correspondante
    const h = town.houses.find(h => h.id === fromId);
    if (!h) return; state.scene = Scenes.Town;
    state.player.x = (h.door.x + h.door.w/2) - state.player.w/2; state.player.y = h.door.y + 6; // juste devant la porte
    flash();
  }

  function flash() {
    // Effet simple en changeant l'opacité de la notif brièvement
    notif.textContent = '...'; notif.classList.add('show');
    setTimeout(()=>{ notif.textContent = 'Entrer '; const k = document.createElement('kbd'); k.textContent='E'; notif.appendChild(k); notif.classList.remove('show');}, 120);
  }

  // ====== Rendu ======
  function draw() {
    // système de coordonnées de base 960x540 (indépendant de l'échelle CSS)
    ctx.save();
    ctx.clearRect(0,0,960,540);

    if (state.scene === Scenes.Town) drawTown(); else drawRoom(rooms[state.scene]);

    // Joueur (dessin par-dessus niveau)
    drawPlayer();

    ctx.restore();
  }

  function drawTown() {
    const cam = state.camera;

    // sol (herbe)
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--grass');
    ctx.fillRect(-0, -0, 960, 540); // fond, inutile mais explicite

    // routes
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--road');
    for (const r of town.roads) fillWorldRect(r, cam);

    // maisons
    for (const h of town.houses) {
      // corps
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--house');
      fillWorldRect(h, cam);
      // toit
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--roof');
      const roof = { x: h.x, y: h.y - 16, w: h.w, h: 16 };
      fillWorldRect(roof, cam);
      // porte
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--door');
      fillWorldRect(h.door, cam);
    }
  }

  function drawRoom(room) {
    const cam = state.camera;
    // sol
    ctx.fillStyle = '#e7d9c8';
    ctx.fillRect(0,0,960,540);
    // murs limites
    ctx.fillStyle = '#c9b7a3';
    const border = 16;
    const walls = [
      { x: 0, y: 0, w: room.w, h: border },
      { x: 0, y: room.h - border, w: room.w, h: border },
      { x: 0, y: 0, w: border, h: room.h },
      { x: room.w - border, y: 0, w: border, h: room.h },
    ];
    for (const w of walls) fillWorldRect(w, cam);
    // mobilier
    ctx.fillStyle = '#9b8b7a';
    for (const f of room.furniture) fillWorldRect(f, cam);
    // sortie (tapis)
    ctx.fillStyle = '#7a5f4b';
    fillWorldRect(room.exit, cam);
  }

  function drawPlayer() {
    const cam = state.camera; const p = state.player;
    const x = Math.floor(p.x - cam.x), y = Math.floor(p.y - cam.y);
    // ombre
    ctx.fillStyle = 'rgba(0,0,0,.2)';
    ctx.beginPath(); ctx.ellipse(x + p.w/2, y + p.h, p.w*.5, 4, 0, 0, Math.PI*2); ctx.fill();
    // corps
    ctx.fillStyle = '#2b6cb0';
    ctx.fillRect(x, y, p.w, p.h);
    // tête
    ctx.fillStyle = '#f1d5b1';
    ctx.fillRect(x + 4, y - 8, p.w - 8, 8);
  }

  function fillWorldRect(r, cam) {
    const x = Math.floor(r.x - cam.x), y = Math.floor(r.y - cam.y);
    ctx.fillRect(x, y, r.w, r.h);
  }

  // Affichage initial d'aide
  setTimeout(()=>{ notif.classList.add('show'); setTimeout(()=>notif.classList.remove('show'), 2000); }, 400);
  </script>
</body>
</html>
